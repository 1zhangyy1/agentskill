{
  "id": "b152775b734944ae",
  "slug": "django-deadcode",
  "name": "Django Deadcode",
  "description": "",
  "author": "nanorepublica",
  "authorAvatar": "https://avatars.githubusercontent.com/u/1997940?v=4",
  "repoUrl": "https://github.com/nanorepublica/django-deadcode",
  "repoFullName": "nanorepublica/django-deadcode",
  "stars": 10,
  "forks": 1,
  "category": "coding",
  "categories": [
    "coding"
  ],
  "tags": [],
  "tier": 3,
  "status": "active",
  "createdAt": "2025-11-11T21:22:23Z",
  "updatedAt": "2025-12-11T21:38:55Z",
  "lastCommitAt": "2025-12-11T21:38:52Z",
  "source": "github-search",
  "collectedAt": "2025-12-23T03:49:48.150Z",
  "authorUrl": "https://github.com/nanorepublica",
  "license": "MIT",
  "readme": "# Django Dead Code\n\nWe find your buried bones (or code)!\n\n[![PyPI version](https://badge.fury.io/py/django-deadcode.svg)](https://badge.fury.io/py/django-deadcode)\n[![CI](https://github.com/nanorepublica/django-deadcode/actions/workflows/ci.yml/badge.svg)](https://github.com/nanorepublica/django-deadcode/actions/workflows/ci.yml)\n[![Python versions](https://img.shields.io/pypi/pyversions/django-deadcode.svg)](https://pypi.org/project/django-deadcode/)\n[![Django versions](https://img.shields.io/pypi/djversions/django-deadcode.svg)](https://pypi.org/project/django-deadcode/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nA Django dead code analysis tool that tracks relationships between templates, URLs, and views to help identify and remove unused code.\n\n## Features\n\n- **Template Analysis**: Extract URL references from Django templates (href attributes and `{% url %}` tags)\n- **URL Pattern Discovery**: Analyze all URL patterns defined in your Django project\n- **View Tracking**: Identify which templates are used by which views\n- **Class-Based View Detection**: Automatically detects templates used by CBVs through Django's implicit naming conventions (ListView, DetailView, CreateView, UpdateView, DeleteView)\n- **Template Variable Detection**: Detects templates referenced through variables containing 'template' in the name\n- **Python Code Analysis**: Detect `reverse()` and `redirect()` URL references in Python code\n- **Relationship Mapping**: Track template inheritance (extends/includes) and relationships\n- **Smart Template Detection**: Templates referenced via `{% include %}` or `{% extends %}` are correctly marked as used\n- **Path Normalization**: Consistent path handling ensures accurate template matching\n- **Project Boundary Filtering**: Automatically excludes templates from installed packages (outside BASE_DIR)\n- **Multiple Output Formats**: Console, JSON, and Markdown reports\n- **Django Native**: Uses Django's management command structure for seamless integration\n\n## Installation\n\n```bash\npip install django-deadcode\n```\n\nOr install from source:\n\n```bash\ngit clone https://github.com/nanorepublica/django-deadcode.git\ncd django-deadcode\npip install -e .\n```\n\n## Setup\n\nAdd `django_deadcode` to your `INSTALLED_APPS`:\n\n```python\nINSTALLED_APPS = [\n    # ... other apps\n    'django_deadcode',\n]\n```\n\n## Usage\n\n### Basic Usage\n\nRun the analysis on your Django project:\n\n```bash\npython manage.py finddeadcode\n```\n\nThis will analyze your entire Django project and output a report to the console.\n\n### Output Formats\n\n**Console output (default):**\n```bash\npython manage.py finddeadcode\n```\n\n**JSON output:**\n```bash\npython manage.py finddeadcode --format json\n```\n\n**Markdown output:**\n```bash\npython manage.py finddeadcode --format markdown\n```\n\n### Save Report to File\n\n```bash\npython manage.py finddeadcode --format json --output report.json\n```\n\n### Analyze Specific Apps\n\n```bash\npython manage.py finddeadcode --apps myapp otherapp\n```\n\n### Custom Template Directory\n\n```bash\npython manage.py finddeadcode --templates-dir /path/to/templates\n```\n\n### Show Template Relationships\n\nBy default, template include/extends relationships are hidden in reports. To show them:\n\n```bash\npython manage.py finddeadcode --show-template-relationships\n```\n\nThis is useful for understanding how templates are connected but can make reports verbose for large projects.\n\n## What It Detects\n\n### Unreferenced URL Patterns\n\nURL patterns that are defined in `urls.py` but never referenced in templates or Python code:\n\n```python\n# urls.py - This URL is defined\npath('old-feature/', views.old_feature, name='old_feature'),\n\n# But no template references it with {% url 'old_feature' %}\n# And no Python code uses reverse('old_feature')\n```\n\n### Class-Based View Default Templates (NEW)\n\nAutomatically detects templates used by class-based views through Django's implicit naming convention:\n\n```python\n# views.py\nfrom django.views.generic import ListView, DetailView\nfrom .models import Article\n\nclass ArticleListView(ListView):\n    model = Article\n    # Automatically detects: myapp/article_list.html\n\nclass ArticleDetailView(DetailView):\n    model = Article\n    # Automatically detects: myapp/article_detail.html\n```\n\nSupported CBV types:\n- `ListView` → `<app_label>/<model_name>_list.html`\n- `DetailView` → `<app_label>/<model_name>_detail.html`\n- `CreateView` → `<app_label>/<model_name>_form.html`\n- `UpdateView` → `<app_label>/<model_name>_form.html`\n- `DeleteView` → `<app_label>/<model_name>_confirm_delete.html`\n\n### Template Variable Detection (NEW)\n\nDetects templates referenced through variables containing 'template' in the name:\n\n```python\n# Simple variable assignment\ntemplate_name = 'myapp/custom.html'\n\n# Method returns\ndef get_template_names(self):\n    return ['myapp/template1.html', 'myapp/template2.html']\n```\n\n### Python Code URL References\n\nDetects URL references in Python code via:\n\n```python\nfrom django.shortcuts import redirect\nfrom django.urls import reverse, reverse_lazy\nfrom django.http import HttpResponseRedirect\n\n# All of these are detected and marked as \"referenced\"\ndef my_view(request):\n    return redirect('url-name')\n\ndef another_view(request):\n    url = reverse('url-name')\n    return HttpResponseRedirect(url)\n\nclass MyView(UpdateView):\n    success_url = reverse_lazy('url-name')\n```\n\n### Unused Templates\n\nTemplates that exist but are not referenced by any view (directly or indirectly through includes/extends):\n\n```python\n# views.py - No view renders 'unused_template.html'\n# And no other template includes or extends it\n\n# But the file templates/unused_template.html exists\n```\n\n**Note**: Templates referenced via `{% include %}` or `{% extends %}` are now correctly identified as used, even if not directly referenced by views.\n\n### Template Relationships\n\nTracks which templates include or extend other templates:\n\n```django\n{# base.html is extended by page.html #}\n{% extends 'base.html' %}\n\n{# header.html is included in base.html #}\n{% include 'partials/header.html' %}\n```\n\nUse the `--show-template-relationships` flag to see these relationships in your report.\n\n## Example Output\n\n```\n================================================================================\nDjango Dead Code Analysis Report\n================================================================================\n\nSUMMARY\n--------------------------------------------------------------------------------\nTotal URL patterns: 45\nTotal templates analyzed: 32\nTotal views found: 28\nUnreferenced URLs: 5\nUnused templates: 3\n\nUNREFERENCED URL PATTERNS\n--------------------------------------------------------------------------------\nThese URL patterns are defined but never referenced in templates:\n\n  • old_feature\n    View: myapp.views.old_feature\n    Pattern: /old-feature/\n\n  • deprecated_api\n    View: myapp.api.deprecated_endpoint\n    Pattern: /api/v1/deprecated/\n\nPOTENTIALLY UNUSED TEMPLATES\n--------------------------------------------------------------------------------\nThese templates are not directly referenced by views (may be included/extended):\n\n  • old_landing.html\n  • unused_email.html\n  • legacy_form.html\n```\n\n## How It Works\n\n1. **Template Analysis**: Scans all template files **within your project's BASE_DIR** for:\n   - `{% url 'name' %}` tags\n   - `href=\"/path/\"` attributes (internal links)\n   - `{% include 'template' %}` tags\n   - `{% extends 'template' %}` tags\n\n2. **Path Normalization**: Normalizes all template paths to Django's relative format (e.g., `app_name/template.html`) ensuring consistent matching between filesystem paths and template references.\n\n3. **Project Boundary Filtering**: Only templates within your project's `BASE_DIR` are analyzed. Templates from installed packages (e.g., Django admin, third-party apps) are automatically excluded.\n\n4. **URL Pattern Discovery**: Inspects Django's URL configuration to find all defined URL patterns and their names\n\n5. **View Analysis**: Parses Python files to find:\n   - `render(request, 'template.html')` calls\n   - `template_name = 'template.html'` in class-based views\n   - Class-based view implicit template names (ListView, DetailView, etc.)\n   - Template variables containing 'template' in the name\n\n6. **Reverse/Redirect Analysis**: Uses AST parsing to detect:\n   - `reverse('url-name')` calls\n   - `reverse_lazy('url-name')` calls\n   - `redirect('url-name')` calls\n   - `HttpResponseRedirect(reverse('url-name'))` patterns\n   - Dynamic URL patterns (f-strings, concatenation) are flagged for manual review\n\n7. **Transitive Template Detection**: Recursively traces template relationships to mark templates as used if they're referenced via `{% include %}` or `{% extends %}` from any used template\n\n8. **Relationship Mapping**: Connects templates ↔ URLs ↔ views to identify dead code\n\n## Limitations\n\n### Static Analysis Only\n- Does not execute code or track runtime behavior\n- Cannot detect templates loaded with dynamic names (e.g., `render(request, f'{variable}.html')`)\n\n### Dynamic Templates\nThe following patterns are **out of scope** and will not be detected:\n- f-string template names: `f'{app_name}/template.html'`\n- Concatenated variables: `template = var1 + var2`\n- Complex conditional logic in `get_template_names()`\n\n### Dynamic URLs\n- Cannot automatically detect URLs generated with f-strings or concatenation\n- These are flagged for manual review in the report\n\n### Third-party Packages\n- Analyzes your code only, not installed packages\n- Templates outside BASE_DIR are automatically excluded\n\n### Function-Based Template Loading\nThe following patterns are **not detected**:\n- `get_template()` function calls\n- `select_template()` function calls\n\nThese may be addressed in future enhancements based on user feedback.\n\n## Troubleshooting\n\n### Templates Incorrectly Flagged as Unused\n\n**Issue**: A template that is actually used is being flagged as unused.\n\n**Possible Causes & Solutions**:\n\n1. **Template Outside BASE_DIR**: Templates from installed packages are automatically excluded. Verify the template is within your project's BASE_DIR.\n\n2. **Dynamic Template Names**: If your view uses dynamic template names (f-strings, concatenation), the tool cannot detect them. Consider refactoring to use explicit template names or adding a comment to track manually.\n\n3. **Custom Template Loaders**: If you're using custom template loaders with non-standard path resolution, the path normalization may not work correctly. Ensure templates are in standard locations.\n\n4. **Template Name Mismatch**: Verify that the template name in your view matches the actual file path relative to the templates directory.\n\n### Class-Based View Templates Not Detected\n\n**Issue**: A CBV's implicit template is not being detected.\n\n**Possible Causes & Solutions**:\n\n1. **Non-Standard App Structure**: The tool infers app labels from file paths. If your app structure is non-standard (e.g., not in an `apps/` directory), the app label inference may fail. Use explicit `template_name` attributes.\n\n2. **Model Not Detected**: If the model is set via a complex expression or `get_queryset()` method, the tool may not detect it. Use explicit `template_name` attributes.\n\n3. **CBV Inheritance**: If your CBV inherits from a custom base class that inherits from Django's generic views, the tool may not detect it. Ensure the direct base class is a Django generic view.\n\n### Path Normalization Issues\n\n**Issue**: Templates are not being matched correctly.\n\n**Possible Causes & Solutions**:\n\n1. **Multiple 'templates' Directories**: If your path contains multiple directories named 'templates' (e.g., `/old_templates/templates/`), the tool uses the last occurrence. Rename directories to avoid confusion.\n\n2. **Symlinked Templates**: Symlinks are resolved to their actual paths. Ensure symlink targets are within BASE_DIR.\n\n3. **Windows Paths**: The tool handles both Unix and Windows path separators. If you encounter issues, please report them as a bug.\n\n### Performance Issues\n\n**Issue**: Analysis takes too long on large projects.\n\n**Expected Performance**:\n- Small project (10 templates): < 1 second\n- Medium project (100 templates): < 5 seconds\n- Large project (1000 templates): < 30 seconds\n\n**Solutions**:\n1. **Analyze Specific Apps**: Use `--apps` flag to limit analysis scope\n2. **Exclude Test/Migration Files**: The tool already skips these, but ensure they're not in unusual locations\n3. **Report a Bug**: If performance is significantly worse than expected, please open an issue\n\n### False Negatives (Unused Code Not Detected)\n\n**Issue**: Dead code exists but is not being detected.\n\n**Possible Causes**:\n1. **Template Used by Third-Party Package**: Templates used by installed packages are not tracked\n2. **Dynamic Template/URL References**: Cannot be detected by static analysis\n3. **Complex Template Chains**: Very complex include/extends chains may have edge cases\n\n**Recommendations**:\n- Review the report manually\n- Cross-reference with code coverage reports\n- Test in a staging environment before deleting templates\n\n## Development\n\n### Setup Development Environment\n\n```bash\n# Clone the repository\ngit clone https://github.com/nanorepublica/django-deadcode.git\ncd django-deadcode\n\n# Install development dependencies\npip install -e \".[dev]\"\n```\n\n### Running Tests\n\n```bash\npytest\n```\n\nWith coverage:\n\n```bash\npytest --cov=django_deadcode --cov-report=html\n```\n\n### Code Quality\n\n```bash\n# Linting\nruff check .\n\n# Type checking\nmypy django_deadcode\n```\n\n## Contributing\n\nContributions are welcome! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for details.\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n## Credits\n\nInspired by the blog post: https://softwarecrafts.co.uk/100-words/day-71\n\n## Roadmap\n\nSee [agent-os/product/roadmap.md](agent-os/product/roadmap.md) for the full development roadmap.\n\n### Planned Features\n\n- Confidence scoring for dead code detection\n- Multi-app analysis with cross-app relationship tracking\n- Django admin integration detection\n- HTML report generation with interactive UI\n- CI/CD integration helpers\n- IDE plugins (VS Code, PyCharm)\n\n## Support\n\n- **Issues**: https://github.com/nanorepublica/django-deadcode/issues\n- **Discussions**: https://github.com/nanorepublica/django-deadcode/discussions\n\n## Changelog\n\n### v0.3.0 (Latest)\n\n**Major Improvements: Template Detection Accuracy**\n\n- **Path Normalization**: Fixed path format mismatch bug that caused false positives. All template paths are now normalized to Django's relative format for consistent matching.\n- **Class-Based View Detection**: Automatically detects templates used by Django's generic CBVs (ListView, DetailView, CreateView, UpdateView, DeleteView) through implicit naming conventions.\n- **Template Variable Detection**: Detects templates referenced through variables containing 'template' in the name, including `get_template_names()` method returns.\n- **Enhanced Template Relationships**: Improved tracking of `{% extends %}` and `{% include %}` relationships with normalized paths.\n- **Production Ready**: Eliminated false positives for the most common use cases. The tool is now trustworthy for identifying genuinely unused templates.\n\n**Performance**: All improvements maintain excellent performance with minimal overhead (<10% impact on large projects).\n\n### Previous Versions\n\nSee [CHANGELOG.md](CHANGELOG.md) for full version history.\n",
  "installCommand": "git clone https://github.com/nanorepublica/django-deadcode ~/.claude/skills/django-deadcode",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}