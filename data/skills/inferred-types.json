{
  "id": "f04df20e6412c144",
  "slug": "inferred-types",
  "name": "Inferred Types",
  "description": "primitives for advanced inference in TS",
  "author": "inocan-group",
  "authorAvatar": "https://avatars.githubusercontent.com/u/46252155?v=4",
  "repoUrl": "https://github.com/inocan-group/inferred-types",
  "repoFullName": "inocan-group/inferred-types",
  "stars": 18,
  "forks": 0,
  "category": "other",
  "categories": [
    "other"
  ],
  "tags": [
    "typescript",
    "utility"
  ],
  "tier": 3,
  "status": "maintained",
  "createdAt": "2021-04-05T17:21:14Z",
  "updatedAt": "2025-11-21T22:52:06Z",
  "lastCommitAt": "2025-11-21T22:52:34Z",
  "source": "github-search",
  "collectedAt": "2025-12-27T03:33:14.001Z",
  "authorUrl": "https://github.com/inocan-group",
  "license": "MIT",
  "readme": "\n![logo](./inferred-types.png)\n\n## Overview\n\nA collection of Typescript utilities which try to preserve as much strong and narrow typing as is possible. In many cases, these _type utilities_ will be paired with a runtime function which provides a runtime mirror to help keep both design time types and runtime values in sync.\n\nAll types -- as well as any pairing runtime functions -- are intended to be \"self documenting\" as much as is possible. This means that they will _at least_ have a description comment which your editor should expose as a popover. In some cases, there are also code examples included in these comments to further flesh out intended use.\n\nTo keep things DRY, the documentation here will be kept to a minimum. This README is intended more as a high level introduction of scope and structure of this repo than documentation.\n\n## Directory Structure\n\nUnder the `src/` folder you'll find the the following subdirectories:\n\n- `constants` - a set of runtime constants that can provide _utility_ to both runtime functions as well as provide foundation for enumerated types.\n- `types` - this folder represents the heart of the repo in the form of _type utilities_ and is further broken down by an attempt at functional classification that hopefully aides somewhat in feature discovery.\n- `runtime` - this is where you'll find runtime functions which mutate state while taking care to provide as much as type information that compliments the runtime environment as is possible.\n\n## Runtime synchronization with Types\n\nYou will find many runtime functions like `ensureLeading(str, substring)` which have a similarly named type (in this case `EnsureLeading<TStr, TSubstring>`). This is no accident and at some future point there may even be something approximating 1:1 parity.\n\nThis connection between the type system and the runtime environment allows both a harmonization of variables across both environments and helps to ensure their consistency but it the runtime environment also often really needs strong type utilities to extract out narrow type definitions in the runtime environment.\n\n## Examples\n\nWhat follows is not meant to be comprehensive set of examples but rather just a sampling that hopefully gives some perspective on the breadth of scope of this library.\n\n### String Literals\n\n#### Casing Conventions\n\n- use `PascalCase<T>`, `CamelCase<T>`, `SnakeCase<T>`, and `KebabCase<T>` to convert a string to one of several familiar naming conventions\n- use `AllCaps<T>` to make all alphanumeric characters into their uppercase variant\n\n#### Pluralization\n\nConvert the _type_ and _value_ of a variable from it's singular form to it's plural form:\n\n```ts\nimport { pluralize } from \"inferred-types\";\n\n// \"people\"\nconst people = pluralize(\"person\");\n```\n\n> **Note:** not only does this utility provide all major grammatical rules used in conversion but has a dictionary of common exceptions it will use too.\n\n#### Consistency with Ensure/Strip utilities\n\n- it's often desirable to _ensure_ that a string _starts with_ or _ends with_ a given string\n- the inverse can also be useful (aka, to _ensure_ a string _does not_ start or end with a given string literal)\n- this library provides `EnsureLeading`, `EnsureTrailing`, `StripLeading`, and `StripTrailing` utilities to meet these type needs\n\n  ```ts\n  import type { EnsureLeading } from \"inferred-types\";\n  // \"start-${string}\"\n  type T1 = EnsureLeading<string, \"start-\">;\n  // \"start-with\"\n  type T2 = EnsureLeading<\"start-with\", \"start-\">;\n  // \"start-with\"\n  type T3 = EnsureLeading<\"with\", \"start-\">;\n  ```\n\n#### Character Sets\n\n- types like `Alpha`, `NumericChar`, `Whitespace`, `Consonants`, etc. try to represent character set building blocks that we may have to isolate on for our own types definitions\n\n#### Data Patterns\n\n- types like `Url`, `IpAddress`, `CSV`, `DotPath`, `Hexadecimal`, `ZipCode`, and `DomainName` attempt to provide an out of the box type for common data structure patterns we find in the real world\n- ISO3166 support (aka, countries):\n  - `Iso3166_Alpha2`, `Iso3166_Alpha3`, ...\n  - `isIso3166Alpha2()`, `isIsoAlpha3()`, type guards ...\n- ISO8601 support (aka, datetime)\n  - `Iso8601DateTime`, `Iso8601Date`, `Iso8601Time`, ...\n  - `isIsoDateTime()`, `isIsoDate()`, `isIsoTime()`, ...\n\nFor more info see [URLs](), [Date and Time](), and\n\n#### String Interpolation\n\n```ts\nconst matcher = infer(\"{{ string }} is a {{ infer foo }} utility, that {{ infer bar }}\");\n// { foo: \"fancy\"; bar: \"thinks it's better than you!\"}\nconst fooBar = matcher(\"infer is a fancy utility, that thinks it's better than you!\")\n```\n\n### Numeric Literals\n\n- use the `Add<A,B>`, `Subtract<A,B>`, `Increment<T>`, `Decrement<T>` utilities to work with numeric types (or even _numeric_ string literals)\n- get the length of a string or tuple with the `Length<T>` utility\n- ensure an _integer_ value with `Integer<T>`; ensure a _float_ value with `Float<T>`\n- compare numeric literals with `LessThan<A,B>`, `LessThanOrEqual<A,B>`, and `GreaterThan<A,B>`\n- ensure a _positive_ number with `Abs<T>`\n- [details on numeric types](./docs/numeric-types.md)\n\n### Lists\n\n- Use `AfterFirst`, `First`, `Last` to index into a tuple / list value\n- Use `AsArray<T>` to ensure an array value for T\n- Use `Flatten<T>` to _flatten_ an array\n- Use `Slice<T,S,E>` to take out a subset of elements in a list\n- Use `Reverse` to reverse a list\n\n### Object / Dictionaries\n\n#### Reduce Object to Keys with a knownValue\n\n  Assume a base type of `Obj`:\n\n  ```ts\n  type Obj = {\n      n1: number;\n      n2: 2;\n      n3: 3;\n      success: true;\n      s1: string;\n      s2: \"hello\";\n  }\n  ```\n\n  We can get a union of string literals representing the _keys_ on the object whose value _extends_ some value:\n\n  ```ts\n  import type { KeysWithValue, KeysWithoutValue } from \"inferred-types\";\n  // \"s1\" | \"s2\"\n  type S = KeysWithValue<Obj, string>;\n  // \"success\" | \"n1\" | \"n2\"\n  type N = KeysWithoutValue<Obj, string>;\n  ```\n\n  > though less used, you can also use `KeysEqualValue` and `KeysNotEqualValue` for equality matching\n\n  If you'd prefer to mutate the object's type rather than just identify the _keys_ which extend a value you can do this with: `WithValue` and `WithoutValue`:\n\n   ```ts\n   import type { WithValue, WithoutValue } from \"inferred-types\";\n   // { s1: string; s2: \"hello\" }\n   type S = WithValue<Obj, string>;\n   // { success: true; n1: number; n2: 2; n3: 3 }\n   type N = WithoutValue<Obj, string>;\n   ```\n\n  And at runtime:\n\n  ```ts\n  // { foo: \"hi\" }\n  const foo = withoutValue(\"number\")({ foo: \"hi\", bar: 42, baz: 99 });\n  // { bar: 42 }\n  const bar = withoutValue(\"number(42,55,66)\")({ foo: \"hi\", bar: 42, baz: 99 });\n\n  // { foo: \"hi\", bar: 42 }\n  const fooBar = withoutKeys(\"baz\")({ foo: \"hi\", bar: 42, baz: 99 });\n  // { foo: \"hi\", bar: 42 }\n  const fooBar2 = withKeys(\"foo\", \"bar\")({ foo: \"hi\", bar: 42, baz: 99 })\n  ```\n\n#### Reduce Object's to only `Required` or `Optional` keys\n\n```ts\ntype Obj = { foo: string; bar?: string; baz?: number };\n// \"foo\"\ntype ReqKeys = RequiredKeys<Obj>;\n// [\"foo\"]\ntype ReqKeyTup = RequiredKeysTuple<Obj>;\n// \"bar\" | \"baz\"\ntype OptKeys = OptionalKeys<Obj>;\n// [\"bar\", \"baz\"]\ntype OptKeyTup = OptionalKeysTuple<Obj>;\n\ntype Reduced =\n\n```\n\n## Contributing\n\nIf you are using this library and would like to take the next step of _contributing_; that effort is welcome but please do make sure to always provide both runtime and type tests for any code changes which you submit as a pull request.\n\nSee the plentiful examples that exist under the `tests/` folder for inspiration.\n\n**Note:** as of 2024 I'm also starting to add \"type performance\" tests; not an absolute requirement but in general adding something like you'll find in the `benches/` folder for any new type utility would be appreciated.\n\n## Licensing\n\nThis repo is offered under the highly permissive MIT license.\n",
  "installCommand": "git clone https://github.com/inocan-group/inferred-types ~/.claude/skills/inferred-types",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}