{
  "id": "d7de629f4d5e513c",
  "slug": "mcpx",
  "name": "Mcpx",
  "description": "Token-efficient MCP client: TypeScript schemas instead of JSON, LLM-friendly syntax, batch calls, TOON output. Built for Claude/GPT automations.",
  "author": "AIGC-Hackers",
  "authorAvatar": "https://avatars.githubusercontent.com/u/140260541?v=4",
  "repoUrl": "https://github.com/AIGC-Hackers/mcpx",
  "repoFullName": "AIGC-Hackers/mcpx",
  "stars": 17,
  "forks": 2,
  "category": "devops",
  "categories": [
    "devops"
  ],
  "tags": [
    "anthropic",
    "automation",
    "batch-operations",
    "claude",
    "claude-skills",
    "cli",
    "codex",
    "cursor",
    "developer-tools",
    "llm-tools",
    "mcp",
    "mcp-client",
    "model-context-protocol",
    "oauth",
    "token-efficient",
    "typescript"
  ],
  "tier": 3,
  "status": "maintained",
  "createdAt": "2025-11-11T02:57:18Z",
  "updatedAt": "2025-11-24T14:01:38Z",
  "lastCommitAt": "2025-11-14T06:29:02Z",
  "source": "github-topic",
  "collectedAt": "2025-12-25T03:40:41.853Z",
  "authorUrl": "https://github.com/AIGC-Hackers",
  "license": "MIT",
  "readme": "# MCPX üß≥\n_Token-efficient MCP client built for LLMs and humans._\n\n**Why MCPX?** Other MCP clients dump giant JSON schemas that waste tokens and confuse humans. MCPX returns **TypeScript signatures** instead‚ÄîClaude and developers instantly understand tool signatures. Call tools with **LLM-native syntax** (`server.func({ args })`), run **batch operations** via stdin, and get **TOON output** (90% fewer tokens than JSON).\n\nMCPX helps you lean into the \"code execution\" workflows highlighted in Anthropic's **Code Execution with MCP** guidance: discover the MCP servers already configured on your system, call them directly, and compose richer automations in TypeScript. All of that works out of the box -- no boilerplate, no schema spelunking.\n\n## Installation\n\n### Homebrew\n\n```bash\n# Add the tap\nbrew tap AIGC-Hackers/mcpx\n\n# Install mcpx\nbrew install mcpx\n\n# Or install in one command\nbrew install AIGC-Hackers/mcpx/mcpx\n```\n\n### Run without installing\n\n```bash\nbunx mcpx list\n```\n\n### Alternate tap (steipete)\n\n```bash\nbrew tap steipete/tap\nbrew install steipete/tap/mcpx\n```\n\n> The steipete tap publishes alongside MCPX 0.3.2. Run `brew update` before reinstalling if you see an older build.\n\n## MCPX vs Other MCP Clients\n\n| Feature | MCPX | Typical MCP Client |\n|---------|------|-------------------|\n| **Schema output** | TypeScript (readable, token-efficient) | JSON Schema (verbose, token-heavy) |\n| **Call syntax** | `linear.createIssue({ title: \"Bug\" })` | Manual JSON construction |\n| **Batch calls** | ‚úÖ Multi-line, stdin, comments | ‚ùå One call at a time |\n| **Output format** | TOON (90% fewer tokens) | Raw JSON |\n| **OAuth flow** | ‚úÖ Auto-triggered, bug-free | Manual or buggy |\n| **LLM-ready** | ‚úÖ Designed for Claude/GPT workflows | ‚ö†Ô∏è Requires token budget |\n\n## Key Capabilities\n\n- **Zero-config discovery.** `createRuntime()` merges `./mcp.json` with `~/.mcpx/mcp.json`, expands `${ENV}` placeholders, and pools connections so you can reuse transports across multiple calls. First run migrates Cursor/Claude/Codex/Windsurf/VS Code configs into `~/.mcpx/mcp.json` automatically.\n- **Flexible data formats.** Call tools with function syntax or structured JSON/JSON5/YAML/TOML data. Output defaults to TOON (LLM-friendly), with `--output` flags for raw/JSON/text formats.\n- **Friendly composable API.** `createServerProxy()` exposes tools as ergonomic camelCase methods, automatically applies JSON-schema defaults, validates required arguments, and hands back a `CallResult` with `.text()`, `.json()`, and `.content()` helpers.\n- **OAuth and stdio ergonomics.** Built-in OAuth caching, log tailing, and stdio wrappers let you work with HTTP, SSE, and stdio transports from the same interface.\n- **Ad-hoc connections.** Point the CLI at *any* MCP endpoint (HTTP or stdio) without touching config, then persist it later if you want. Hosted MCPs that expect a browser login (Supabase, Vercel, etc.) are auto-detected and OAuth is triggered automatically when needed. See [docs/adhoc.md](docs/adhoc.md).\n\n## Quick Start\n\nMCPX auto-discovers the MCP servers you already configured in Cursor, Claude Code/Desktop, Codex, or local overrides. Install via Homebrew or run instantly with `bunx mcpx`. Need a full command reference (flags, modes, return types)? Check out [docs/cli-reference.md](docs/cli-reference.md).\n\n### Call MCP tools\n\n```bash\n# Function syntax - natural for agents and interactive use\nmcpx call 'linear.create_comment({ issueId: \"ENG-123\", body: \"Great!\" })'\n\n# Data format - explicit and structured (JSON5/YAML/TOML also supported)\nmcpx call '{ tool: \"linear.create_comment\", args: { issueId: \"ENG-123\", body: \"Great!\" } }'\n```\n\n\n### List your MCP servers\n\n```bash\nmcpx list\nmcpx list context7\nmcpx list https://mcp.linear.app/mcp --all-parameters\nmcpx list shadcn.io/api/mcp.getComponents           # URL + tool suffix auto-resolves\nmcpx list --stdio \"bun run ./local-server.ts\" --env TOKEN=xyz\n```\n\n- Add `--output json` to emit a machine-readable summary with per-server statuses (auth/offline/http/error counts) and, for single-server runs, the full tool schema payload.\n\nYou can now point `mcpx list` at ad-hoc servers: provide a URL directly or use the new `--http-url/--stdio` flags (plus `--env`, `--cwd`, `--name`, or `--persist`) to describe any MCP endpoint. Until you persist that definition, you still need to repeat the same URL/stdio flags for `mcpx call`‚Äîthe printed slug only becomes reusable once you merge it into a config via `--persist` or `mcpx config add`. OAuth is triggered automatically when servers require authentication. Full details live in [docs/adhoc.md](docs/adhoc.md).\n\nSingle-server listings now show TypeScript Spec format so you can copy/paste the signature straight into `mcpx call`:\n\n```ts\nlinear - Hosted Linear MCP\n  23 tools ¬∑ 1654ms ¬∑ HTTP https://mcp.linear.app/mcp\n\n/**\n * Create a comment on a specific Linear issue\n */\ntype CreateCommentSpec = {\n  tool: 'create_comment'\n  args: {\n    issueId: string\n    body: string\n    parentId?: string\n    notifySubscribers?: boolean\n    labelIds?: string[]\n    mentionIds?: string[]\n  }\n}\n\n/**\n * List documents in the user's Linear workspace\n */\ntype ListDocumentsSpec = {\n  tool: 'list_documents'\n  args: {\n    query?: string\n    limit?: number\n    before?: string\n    after?: string\n    orderBy?: 'createdAt' | 'updatedAt'\n    projectId?: string\n    initiativeId?: string\n    creatorId?: string\n    includeArchived?: boolean\n  }\n}\n```\n\nHere's what that looks like for Vercel when you run `mcpx list vercel`:\n\n```ts\nvercel - Vercel MCP (requires OAuth)\n\n/**\n * Search the Vercel documentation.\n * Use this tool to answer any questions about Vercel's platform, features, and best practices.\n */\ntype SearchVercelDocumentationSpec = {\n  tool: 'search_vercel_documentation'\n  args: {\n    topic: string\n    tokens?: number\n  }\n}\n\n/**\n * Deploy the current project to Vercel\n */\ntype DeployToVercelSpec = {\n  tool: 'deploy_to_vercel'\n  args: Record<string, unknown>\n}\n```\n\n### Context7: fetch docs (no auth required)\n\n```bash\nmcpx call 'context7.resolve-library-id({ libraryName: \"react\" })'\nmcpx call 'context7.get-library-docs({ path: \"/websites/react_dev\", topic: \"hooks\" })'\n```\n\n### Linear: search documentation (requires `LINEAR_API_KEY`)\n\n```bash\nLINEAR_API_KEY=sk_linear_example mcpx call 'linear.search_documentation({ query: \"automations\" })'\n```\n\n### Chrome DevTools: snapshot the current tab\n\n```bash\nmcpx call 'chrome-devtools.take_snapshot()'\nmcpx call 'linear.create_comment({ issueId: \"LNR-123\", body: \"Hello world\" })'\n```\n\n> **Call Syntax:** Function syntax `server.tool({ args })` or data format `{ tool: \"server.tool\", args: {...} }`. Both are parsed (not executed as JS). Supports JSON5/YAML/TOML.\n\nHelpful flags:\n\n- `--config <path>` -- custom config file (overrides the default `./mcp.json` + `~/.mcpx/mcp.json` merge).\n- `--root <path>` -- working directory for stdio commands.\n- `--log-level <debug|info|warn|error>` -- adjust verbosity (respects `MCPX_LOG_LEVEL`).\n- `--oauth-timeout <ms>` -- shorten/extend the OAuth browser wait; same as `MCPX_OAUTH_TIMEOUT_MS` / `MCPX_OAUTH_TIMEOUT`.\n- `--tail-log` -- stream the last 20 lines of any log files referenced by the tool response.\n- `--output <format>` -- control output format: `toon` (default, LLM-friendly), `json`, `text`, or `raw`.\n- `--http-url <https://‚Ä¶>` / `--stdio \"command ‚Ä¶\"` -- describe an ad-hoc MCP server inline (pair with `--env KEY=value`, `--cwd`, `--name`, and `--persist <config.json>` as needed).\n- OAuth-protected servers trigger authentication automatically on first use.\n\n> Tip: You can skip the verb entirely‚Äî`mcpx firecrawl` automatically runs `mcpx list firecrawl`, and dotted tokens like `mcpx linear.list_issues` dispatch to the call command (typo fixes included).\n\nTimeouts default to 30 s; override with `MCPX_LIST_TIMEOUT` or `MCPX_CALL_TIMEOUT` when you expect slow startups. OAuth browser handshakes get a separate 60 s grace period; pass `--oauth-timeout <ms>` (or export `MCPX_OAUTH_TIMEOUT_MS`) when you need the CLI to bail out faster while you diagnose stubborn auth flows.\n\n### Try an MCP without editing config\n\n```bash\n# Point at an HTTPS MCP server directly\nmcpx list --http-url https://mcp.linear.app/mcp --name linear\n\n# Run a local stdio MCP server via Bun\nmcpx call --stdio \"bun run ./local-server.ts\" --name local-tools\n```\n\n- Add `--persist ~/.mcpx/mcp.json` (or any path) to save the inferred definition for future runs.\n- Use `--allow-http` if you truly need to hit a cleartext endpoint.\n- See [docs/adhoc.md](docs/adhoc.md) for a deep dive (env overrides, cwd, OAuth).\n\n\n## Call Syntax\n\nTwo formats, both parsed (not executed as JavaScript):\n\n**Function syntax** (natural for agents):\n```bash\nmcpx call 'linear.create_issue({ title: \"Bug\", priority: 2, labels: [\"urgent\"] })'\n```\n\n**Data format** (explicit, supports JSON5/YAML/TOML):\n```bash\nmcpx call '{ tool: \"linear.create_issue\", args: { title: \"Bug\", priority: 2 } }'\n```\n\n**Features:**\n- **Auto-correct.** Typo `listIssue`? MCPX suggests `list_issues` automatically.\n- **Type specs.** `mcpx list <server>` prints TypeScript specs‚Äîcopy/paste directly into calls.\n\n## Batch Calling\n\nExecute multiple MCP tool calls in one shot from stdin or a file. Perfect for LLM-driven workflows, automation scripts, and data migrations.\n\n```bash\n# From file\ncat batch-calls.txt | mcpx call\n\n# From heredoc (function syntax)\nmcpx call << 'EOF'\nlinear.list_issues({ limit: 5 })\ngithub.search_repos({ query: \"mcp\" })\nEOF\n\n# Data format also works\nmcpx call << 'EOF'\n[\n  { tool: \"linear.list_issues\", args: { limit: 5 } },\n  { tool: \"github.search_repos\", args: { query: \"mcp\" } }\n]\nEOF\n```\n\n**Input format** supports function syntax and structured data:\n\n```javascript\n// Function syntax (one per line, natural for agents)\nlinear.create_issue({ title: \"Fix bug\", priority: 2, labels: [\"bug\", \"urgent\"] })\ngithub.search_repos({ query: \"mcp\" })\n\n// Data format (explicit structure)\n[\n  { tool: \"linear.create_issue\", args: { title: \"Fix bug\", priority: 2, labels: [\"bug\", \"urgent\"] } },\n  { tool: \"github.search_repos\", args: { query: \"mcp\" } }\n]\n```\n\n**Output** is in **TOON format** (compact, LLM-friendly):\n\n```toon\n[2]:\n  - tool: linear.create_issue\n    output:\n      id: ISS-123\n      title: Fix bug\n  - tool: github.search_repos\n    output:\n      items[1]{name,stars}: repo1,42\n```\n\nOverride with `--output json` for standard JSON:\n\n```json5\n[\n  { tool: 'linear.create_issue', output: { id: 'ISS-123', title: 'Fix bug' } },\n  { tool: 'github.search_repos', output: { items: [...] } },\n]\n```\n\n**Error handling**: If any call fails, the error is captured in the output and the exit code is `1`:\n\n```json5\n{\n  tool: 'linear.bad_tool',\n  output: \"Parameter validation failed:\\n- Field 'id': Required (expected string, got undefined)\",\n}\n```\n\nUse cases:\n- **LLM tool calling**: Generate batch files and pipe to mcpx\n- **Automation scripts**: Daily standups, status reports\n- **Data migration**: Export from one system, import to another\n\nSee [examples/README.md](examples/README.md) and [examples/batch-calls.txt](examples/batch-calls.txt) for complete examples.\n\nNeed runtime or automation samples? Head to [docs/tool-calling.md](docs/tool-calling.md) and [docs/cli-reference.md](docs/cli-reference.md). Call `mcpx list <server>` any time you need the TypeScript-style signature, optional parameter hints, and sample invocations that match the CLI's function-call syntax.\n\n## Configuration Reference\n\n`mcp.json` (project) and `~/.mcpx/mcp.json` (user) share the Cursor/Claude schema:\n\n```json5\n{\n\tmcpServers: {\n\t\tcontext7: {\n\t\t\tdescription: 'Context7 docs MCP',\n\t\t\tbaseUrl: 'https://mcp.context7.com/mcp',\n\t\t\theaders: {\n\t\t\t\tAuthorization: '$env:CONTEXT7_API_KEY',\n\t\t\t},\n\t\t},\n\t\t'chrome-devtools': {\n\t\t\tcommand: 'bunx',\n\t\t\targs: ['chrome-devtools-mcp@latest'],\n\t\t},\n\t},\n}\n```\n\nWhat MCPX handles for you:\n\n- `${VAR}`, `${VAR:-fallback}`, and `$env:VAR` interpolation for headers and env entries across both files. Entries defined in `./mcp.json` override duplicates from `~/.mcpx/mcp.json`.\n- Automatic OAuth token caching under `~/.mcpx/<server>/` unless you override `tokenCacheDir`.\n- Stdio commands inherit the directory of the file that defined them (imports or local config).\n- First run populates `~/.mcpx/mcp.json` by migrating Cursor/Claude/Codex/Windsurf/VS Code configs; legacy `imports` arrays are only read during that migration helper.\n\nProvide `configPath` or `rootDir` to CLI/runtime calls when you juggle multiple config files side by side.\n\n## Debug Hanging Servers Quickly\n\nUse `tmux` to keep long-running CLI sessions visible while you investigate lingering MCP transports:\n\n```bash\ntmux new-session -- bun run mcpx:list\n```\n\nLet it run in the background, then inspect the pane (`tmux capture-pane -pt <session>`), tail stdio logs, or kill the session once the command exits. Pair this with `MCPX_DEBUG_HANG=1` when you need verbose handle diagnostics. More detail: [docs/tmux.md](docs/tmux.md) and [docs/hang-debug.md](docs/hang-debug.md).\n\n## Credits\n\nMCPX was inspired by [mcporter](https://github.com/steipete/mcporter) but rebuilt from scratch with token-efficiency and LLM workflows as first-class design goals.\n\n## License\n\nMIT -- see [LICENSE](LICENSE).\n\nFurther reading: [docs/tool-calling.md](docs/tool-calling.md), [docs/adhoc.md](docs/adhoc.md), [docs/tmux.md](docs/tmux.md).\n",
  "installCommand": "git clone https://github.com/AIGC-Hackers/mcpx ~/.claude/skills/mcpx",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}