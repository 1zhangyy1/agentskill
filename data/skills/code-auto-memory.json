{
  "id": "b0cdc27ef75d5d85",
  "slug": "code-auto-memory",
  "name": "Code Auto Memory",
  "description": "Claude Code plugin that automatically maintains CLAUDE.md files",
  "author": "severity1",
  "authorAvatar": "https://avatars.githubusercontent.com/u/1973846?v=4",
  "repoUrl": "https://github.com/severity1/claude-code-auto-memory",
  "repoFullName": "severity1/claude-code-auto-memory",
  "stars": 69,
  "forks": 2,
  "category": "automation",
  "categories": [
    "automation"
  ],
  "tags": [],
  "tier": 2,
  "status": "active",
  "createdAt": "2025-11-26T10:47:09Z",
  "updatedAt": "2025-12-19T16:05:33Z",
  "lastCommitAt": "2025-12-13T08:51:42Z",
  "source": "github-search",
  "collectedAt": "2025-12-22T03:56:18.560Z",
  "authorUrl": "https://github.com/severity1",
  "license": "MIT",
  "readme": "# claude-code-auto-memory\n\n**Your CLAUDE.md, always in sync.** Minimal tokens. Zero config. Just works.\n\nA Claude Code plugin that watches what Claude Code edits, deletes, and moves - then quietly updates your project memory in the background. No manual maintenance needed.\n\n[![Claude Code Plugin](https://img.shields.io/badge/Claude%20Code-Plugin-blueviolet)](https://claude.ai/code)\n[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)\n[![Zero Config](https://img.shields.io/badge/setup-zero--config-brightgreen)]()\n[![Token Efficient](https://img.shields.io/badge/tokens-minimal--overhead-blue)]()\n\n## The Problem\n\nCLAUDE.md files become stale as codebases evolve:\n\n- Build commands change but memory stays outdated\n- Architecture shifts go unrecorded\n- Code conventions drift without memory updates\n- New team members get incorrect context\n\n**Manual maintenance is tedious and often forgotten.**\n\n## The Solution\n\nclaude-code-auto-memory automatically updates CLAUDE.md when Claude Code makes changes. Processing happens in an isolated agent, so it doesn't consume your main conversation's context window.\n\n```\nClaude Code edits code -> Plugin tracks changes -> Isolated agent updates memory -> Context stays fresh\n```\n\n## Features\n\n- **Automatic sync**: Tracks Edit/Write/Bash operations and updates CLAUDE.md at end of turn\n- **Bash operation tracking**: Detects rm, mv, git rm, git mv, unlink commands\n- **Minimal-token tracking**: PostToolUse hook has no output; stop hook triggers isolated agent\n- **Isolated processing**: Agent runs in separate context window, doesn't consume main session tokens\n- **Marker-based updates**: Only modifies AUTO-MANAGED sections, preserves manual content\n- **Subtree support**: Hierarchical CLAUDE.md for monorepos\n\n## Installation\n\n### From Marketplace\n\n```bash\nclaude plugin marketplace add severity1/severity1-marketplace\nclaude plugin install auto-memory@severity1-marketplace\n```\n\n### Local Development\n\n```bash\n# Add local marketplace\nclaude plugin marketplace add /path/to/claude-code-auto-memory/.dev-marketplace/.claude-plugin/marketplace.json\n\n# Install from local\nclaude plugin install auto-memory@local-dev\n```\n\n## Commands\n\n### `/auto-memory:init`\n\nInitialize CLAUDE.md structure for your project with an interactive wizard.\n\n```\n/auto-memory:init\n```\n\nThe wizard will:\n1. Analyze your codebase structure\n2. Detect frameworks and build commands\n3. Identify subtree candidates (for monorepos)\n4. Present findings for your approval\n5. Generate CLAUDE.md with auto-managed sections\n\n### `/auto-memory:calibrate`\n\nForce a full recalibration of all CLAUDE.md files.\n\n```\n/auto-memory:calibrate\n```\n\n### `/auto-memory:sync`\n\nSync CLAUDE.md with manual file changes detected by git. Use this when you've edited files outside Claude Code (in your IDE, terminal, etc.) and want to update memory without a full recalibration.\n\n```\n/auto-memory:sync\n```\n\nDetects:\n- Modified tracked files (`git diff`)\n- Staged files (`git diff --cached`)\n- New untracked files (`git ls-files --others`)\n\n### `/auto-memory:status`\n\nShow current sync status and pending changes.\n\n```\n/auto-memory:status\n```\n\n## How It Works\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Claude as Claude Code\n    participant PostHook as PostToolUse Hook\n    participant DirtyFiles as dirty-files\n    participant StopHook as Stop Hook\n    participant Agent as memory-updater Agent\n    participant Skill as memory-processor Skill\n\n    User->>Claude: Edit files\n    Claude->>PostHook: Edit/Write/Bash operation\n    PostHook->>DirtyFiles: Append file path (zero tokens)\n    Note over PostHook: No output - pure tracking\n\n    User->>Claude: Continue working...\n    Claude->>PostHook: More edits\n    PostHook->>DirtyFiles: Append paths\n\n    Note over Claude: Turn ends\n    Claude->>StopHook: End of turn\n    StopHook->>DirtyFiles: Check for dirty files\n\n    alt Dirty files exist\n        StopHook->>Agent: Spawn isolated agent\n        Agent->>Skill: Invoke memory-processor\n        Skill->>Skill: Analyze changes\n        Skill->>Skill: Update CLAUDE.md sections\n        Agent-->>StopHook: Complete\n        StopHook->>DirtyFiles: Clear processed files\n    else No dirty files\n        Note over StopHook: No action needed\n    end\n```\n\n### Architecture Overview\n\n```\nPostToolUse Hook (Edit|Write|Bash)\n    |\n    v (append file paths)\n.claude/auto-memory/dirty-files\n    |\n    v (end of turn)\nStop Hook\n    |\n    v (spawn agent)\nmemory-updater Agent (isolated context)\n    |\n    v (invoke skill)\nmemory-processor Skill\n    |\n    v\nCLAUDE.md updated\n```\n\n### Token Efficiency\n\n- **PostToolUse hook**: Zero token cost (no output)\n- **Stop hook**: Minimal output only when dirty files exist\n- **Agent**: Runs in isolated context window - doesn't consume main session tokens\n- **Skills**: Progressive disclosure - load only when invoked\n\n## CLAUDE.md Format\n\nAuto-managed sections use HTML comment markers:\n\n```markdown\n<!-- AUTO-MANAGED: section-name -->\nContent automatically updated by plugin\n<!-- END AUTO-MANAGED -->\n\n<!-- MANUAL -->\nContent never touched by plugin\n<!-- END MANUAL -->\n```\n\n### Supported Sections\n\n- `project-description` - Project overview\n- `build-commands` - Build, test, lint commands\n- `architecture` - Directory structure, components\n- `conventions` - Code standards, naming patterns\n- `patterns` - AI-detected coding patterns\n- `git-insights` - Decisions from commit history\n- `best-practices` - From official Claude Code docs\n\n## Configuration\n\nOptional configuration is stored in `.claude/auto-memory/config.json`.\n\n### Trigger Modes\n\nControl when auto-memory triggers CLAUDE.md updates:\n\n```json\n{\n  \"triggerMode\": \"default\"\n}\n```\n\n| Mode | Behavior |\n|------|----------|\n| `default` | Track file edits in real-time (Edit/Write/Bash operations). Best for most workflows. |\n| `gitmode` | Only trigger on `git commit`. Best for developers who commit frequently. |\n\n**Note**: If no config file exists, `default` mode is used.\n\n### Git Commit Enrichment\n\nWhen a `git commit` is detected (in both modes), auto-memory captures the commit context:\n- Commit hash and message are stored inline with each file path: `/path/to/file [hash: message]`\n- The memory-updater agent uses this to provide semantic context: \"Changes from commit [hash]: [message]\"\n\nThis helps CLAUDE.md updates reflect the *intent* behind changes, not just which files changed.\n\n### Data Files\n\n| File | Location | Purpose |\n|------|----------|---------|\n| `dirty-files` | `.claude/auto-memory/` | List of files pending CLAUDE.md update |\n| `config.json` | `.claude/auto-memory/` | Trigger mode configuration |\n\n## Development\n\n### Setup\n\n```bash\n# Install dev dependencies\nuv sync --extra dev\n\n# Run tests\nuv run pytest\n\n# Format code\nuv run ruff format .\n\n# Lint\nuv run ruff check .\n\n# Type check\nuv run mypy .\n```\n\n### Project Structure\n\n```\nclaude-code-auto-memory/\n├── .claude-plugin/\n│   └── plugin.json           # Plugin metadata\n├── hooks/\n│   └── hooks.json            # Hook registration\n├── scripts/\n│   ├── post-tool-use.py      # Track file changes\n│   └── stop.py               # End-of-turn trigger\n├── agents/\n│   └── memory-updater.md     # Orchestrator agent\n├── skills/\n│   ├── memory-processor/     # Update processing\n│   └── codebase-analyzer/    # Init wizard\n├── commands/\n│   ├── init.md               # /auto-memory:init\n│   ├── calibrate.md          # /auto-memory:calibrate\n│   ├── sync.md               # /auto-memory:sync\n│   └── status.md             # /auto-memory:status\n└── tests/\n```\n\n## Why claude-code-auto-memory?\n\n| Feature | claude-code-auto-memory | Other Solutions |\n|---------|-------------------|-----------------|\n| Token overhead | **Minimal** (isolated agent) | Hook output adds tokens |\n| External deps | **None** | SQLite, Vector DBs, Workers |\n| Processing | **Isolated agent** | Inline or external service |\n| Updates | **Marker-based** | Full file regeneration |\n| Monorepo | **Subtree CLAUDE.md** | Root only |\n| Config required | **Optional** (zero-config default) | Config files needed |\n\nSee also: [memory-store-plugin](https://github.com/julep-ai/memory-store-plugin), [claude-mem](https://github.com/thedotmack/claude-mem), [claude-code-branch-memory-manager](https://github.com/Davidcreador/claude-code-branch-memory-manager)\n\n## License\n\nMIT\n\n---\n\n**Keywords**: Claude Code plugin, CLAUDE.md, automatic memory, memory management, context persistence, token-efficient, zero-config, monorepo, AI coding assistant\n",
  "installCommand": "git clone https://github.com/severity1/claude-code-auto-memory ~/.claude/skills/code-auto-memory",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}