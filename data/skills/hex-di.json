{
  "id": "84976b34d2b64873",
  "slug": "hex-di",
  "name": "Hex Di",
  "description": "",
  "author": "leaderiop",
  "authorAvatar": "https://avatars.githubusercontent.com/u/10500831?v=4",
  "repoUrl": "https://github.com/leaderiop/hex-di",
  "repoFullName": "leaderiop/hex-di",
  "stars": 5,
  "forks": 0,
  "category": "other",
  "categories": [
    "other"
  ],
  "tags": [],
  "tier": 3,
  "status": "active",
  "createdAt": "2025-12-15T00:33:06Z",
  "updatedAt": "2025-12-20T23:04:42Z",
  "lastCommitAt": "2025-12-20T23:04:38Z",
  "source": "github-search",
  "collectedAt": "2025-12-23T03:47:10.884Z",
  "authorUrl": "https://github.com/leaderiop",
  "license": null,
  "readme": "# HexDI\n\n> Type-safe dependency injection for TypeScript with compile-time validation\n\nHexDI is a modern dependency injection framework designed for TypeScript applications. It catches dependency errors at compile time, not runtime, and provides first-class React integration with zero global state.\n\n## Key Features\n\n- **Compile-Time Validation** - Missing dependencies cause TypeScript errors, not runtime crashes\n- **Type-Safe Resolution** - Full type inference, no explicit type annotations needed\n- **Three Lifetime Scopes** - Singleton, scoped, and request lifetimes with proper isolation\n- **Immutable Builder Pattern** - Effect-TS inspired composition that enables graph branching\n- **React Integration** - Typed hooks and providers with automatic scope lifecycle\n- **DevTools** - Visualize dependency graphs and trace service resolution\n- **Zero Runtime Overhead** - Phantom types and optional features add no cost when unused\n\n## Quick Start\n\n```typescript\nimport { createPort } from '@hex-di/ports';\nimport { createAdapter, GraphBuilder } from '@hex-di/graph';\nimport { createContainer } from '@hex-di/runtime';\n\n// 1. Define your service interface\ninterface Logger {\n  log(message: string): void;\n}\n\n// 2. Create a port (contract + runtime token)\nconst LoggerPort = createPort<'Logger', Logger>('Logger');\n\n// 3. Create an adapter (implementation)\nconst LoggerAdapter = createAdapter({\n  provides: LoggerPort,\n  requires: [],\n  lifetime: 'singleton',\n  factory: () => ({\n    log: (msg) => console.log(`[App] ${msg}`)\n  })\n});\n\n// 4. Build the graph (validated at compile time)\nconst graph = GraphBuilder.create()\n  .provide(LoggerAdapter)\n  .build();\n\n// 5. Create container and resolve services\nconst container = createContainer(graph);\nconst logger = container.resolve(LoggerPort);\nlogger.log('Hello, HexDI!');\n```\n\n## Installation\n\n### Core Packages (Required)\n\n```bash\n# Using pnpm (recommended)\npnpm add @hex-di/ports @hex-di/graph @hex-di/runtime\n\n# Using npm\nnpm install @hex-di/ports @hex-di/graph @hex-di/runtime\n\n# Using yarn\nyarn add @hex-di/ports @hex-di/graph @hex-di/runtime\n```\n\n### Optional Packages\n\n```bash\n# React integration\npnpm add @hex-di/react\n\n# DevTools for visualization\npnpm add @hex-di/devtools\n\n# Testing utilities\npnpm add -D @hex-di/testing\n```\n\n### All Packages\n\n```bash\npnpm add @hex-di/ports @hex-di/graph @hex-di/runtime @hex-di/react @hex-di/devtools\npnpm add -D @hex-di/testing\n```\n\n## Packages Overview\n\n| Package | Description | Required |\n|---------|-------------|----------|\n| [`@hex-di/ports`](./packages/ports) | Port token system - define service contracts | Yes |\n| [`@hex-di/graph`](./packages/graph) | GraphBuilder with compile-time dependency validation | Yes |\n| [`@hex-di/runtime`](./packages/runtime) | Container creation and service resolution | Yes |\n| [`@hex-di/react`](./packages/react) | React hooks and providers | No |\n| [`@hex-di/devtools`](./packages/devtools) | Graph visualization and tracing | No |\n| [`@hex-di/testing`](./packages/testing) | Mocking, overrides, and test utilities | No |\n\n## Core Concepts\n\n### Ports\n\nPorts are typed tokens that represent service contracts. They serve as both runtime identifiers and compile-time type carriers.\n\n```typescript\nimport { createPort } from '@hex-di/ports';\n\ninterface UserService {\n  getUser(id: string): Promise<User>;\n}\n\n// createPort<'PortName', ServiceInterface>('PortName')\nconst UserServicePort = createPort<'UserService', UserService>('UserService');\n```\n\n### Adapters\n\nAdapters implement ports and declare their dependencies. The factory function receives typed dependencies automatically.\n\n```typescript\nimport { createAdapter } from '@hex-di/graph';\n\nconst UserServiceAdapter = createAdapter({\n  provides: UserServicePort,\n  requires: [LoggerPort, DatabasePort],  // Dependencies\n  lifetime: 'scoped',\n  factory: (deps) => {\n    // deps is typed as { Logger: Logger; Database: Database }\n    return {\n      getUser: async (id) => {\n        deps.Logger.log(`Fetching user ${id}`);\n        return deps.Database.query('SELECT * FROM users WHERE id = ?', [id]);\n      }\n    };\n  }\n});\n```\n\n### GraphBuilder\n\nGraphBuilder composes adapters into a validated dependency graph using an immutable, fluent API.\n\n```typescript\nimport { GraphBuilder } from '@hex-di/graph';\n\nconst graph = GraphBuilder.create()\n  .provide(LoggerAdapter)      // singleton, no deps\n  .provide(DatabaseAdapter)    // singleton, no deps\n  .provide(UserServiceAdapter) // scoped, requires Logger & Database\n  .build(); // Compile error if dependencies are missing!\n```\n\n### Container & Scopes\n\nContainers resolve services from the graph. Scopes provide isolation for scoped services.\n\n```typescript\nimport { createContainer } from '@hex-di/runtime';\n\nconst container = createContainer(graph);\n\n// Resolve singleton services directly\nconst logger = container.resolve(LoggerPort);\n\n// Create scopes for scoped services\nconst scope = container.createScope();\nconst userService = scope.resolve(UserServicePort);\n\n// Cleanup when done\nawait scope.dispose();\nawait container.dispose();\n```\n\n## Lifetime Scopes\n\n| Lifetime | Instance Creation | Use Case |\n|----------|-------------------|----------|\n| `singleton` | Once per container | Stateless services, shared resources |\n| `scoped` | Once per scope | Request context, user sessions |\n| `request` | Every resolution | Fresh instances, isolation |\n\n```typescript\n// Singleton - shared across entire app\nconst ConfigAdapter = createAdapter({\n  provides: ConfigPort,\n  requires: [],\n  lifetime: 'singleton',\n  factory: () => ({ apiUrl: 'https://api.example.com' })\n});\n\n// Scoped - one per scope (e.g., per HTTP request)\nconst UserSessionAdapter = createAdapter({\n  provides: UserSessionPort,\n  requires: [],\n  lifetime: 'scoped',\n  factory: () => ({ userId: getCurrentUserId() })\n});\n\n// Request - new instance every time\nconst NotificationAdapter = createAdapter({\n  provides: NotificationPort,\n  requires: [],\n  lifetime: 'request',\n  factory: () => ({ id: generateId(), createdAt: new Date() })\n});\n```\n\n## React Integration\n\n```typescript\nimport { createTypedHooks } from '@hex-di/react';\nimport { createContainer } from '@hex-di/runtime';\n\n// Create typed hooks for your app's ports\nconst {\n  ContainerProvider,\n  AutoScopeProvider,\n  usePort\n} = createTypedHooks<AppPorts>();\n\n// App setup\nconst container = createContainer(graph);\n\nfunction App() {\n  return (\n    <ContainerProvider container={container}>\n      <Dashboard />\n    </ContainerProvider>\n  );\n}\n\n// Use services in components\nfunction Dashboard() {\n  const logger = usePort(LoggerPort);\n\n  useEffect(() => {\n    logger.log('Dashboard mounted');\n  }, [logger]);\n\n  return (\n    <AutoScopeProvider>\n      <UserProfile />\n    </AutoScopeProvider>\n  );\n}\n\nfunction UserProfile() {\n  const session = usePort(UserSessionPort); // Scoped to AutoScopeProvider\n  return <div>Welcome, {session.user.name}</div>;\n}\n```\n\n## Compile-Time Safety\n\nHexDI catches errors at compile time with readable error messages:\n\n```typescript\n// Missing dependency\nconst graph = GraphBuilder.create()\n  .provide(UserServiceAdapter) // requires Logger, Database\n  .build();\n// Error: Expected 1 argument, but got 0.\n// Shows: MissingDependencyError<typeof LoggerPort | typeof DatabasePort>\n\n// Duplicate provider\nconst graph = GraphBuilder.create()\n  .provide(LoggerAdapter)\n  .provide(AnotherLoggerAdapter) // same port\n  .build();\n// Error: DuplicateProviderError<typeof LoggerPort>\n\n// Invalid port resolution\ncontainer.resolve(UnknownPort);\n// Error: Argument of type 'typeof UnknownPort' is not assignable...\n```\n\n## DevTools\n\nVisualize your dependency graph and trace service resolution:\n\n```typescript\nimport { DevToolsFloating, createTracingContainer } from '@hex-di/devtools';\n\n// Create a tracing container for detailed insights\nconst container = createTracingContainer(graph);\n\n// Add DevTools to your app\nfunction App() {\n  return (\n    <ContainerProvider container={container}>\n      <MyApp />\n      <DevToolsFloating\n        graph={graph}\n        container={container}\n        position=\"bottom-right\"\n      />\n    </ContainerProvider>\n  );\n}\n```\n\nExport graphs for documentation:\n\n```typescript\nimport { toMermaid, toDOT, toJSON } from '@hex-di/devtools';\n\n// Generate Mermaid diagram\nconsole.log(toMermaid(graph));\n\n// Generate Graphviz DOT\nconsole.log(toDOT(graph));\n\n// Export as JSON\nconsole.log(JSON.stringify(toJSON(graph), null, 2));\n```\n\n## Testing\n\nOverride adapters for testing without touching production code:\n\n```typescript\nimport { TestGraphBuilder, createMockAdapter } from '@hex-di/testing';\nimport { createContainer } from '@hex-di/runtime';\n\n// Create mock adapters\nconst mockLogger = createMockAdapter(LoggerPort, {\n  log: vi.fn(),\n  warn: vi.fn(),\n  error: vi.fn()\n});\n\n// Build test graph with overrides\nconst testGraph = TestGraphBuilder.from(productionGraph)\n  .override(mockLogger)\n  .build();\n\n// Create test container\nconst container = createContainer(testGraph);\n\n// Test your services\nconst userService = container.resolve(UserServicePort);\nawait userService.getUser('123');\n\nexpect(mockLogger.log).toHaveBeenCalledWith('Fetching user 123');\n```\n\n## Error Handling\n\nAll container errors extend `ContainerError` with stable error codes:\n\n```typescript\nimport {\n  ContainerError,\n  CircularDependencyError,\n  FactoryError,\n  DisposedScopeError,\n  ScopeRequiredError\n} from '@hex-di/runtime';\n\ntry {\n  const service = container.resolve(SomePort);\n} catch (error) {\n  if (error instanceof CircularDependencyError) {\n    console.error('Circular dependency detected:', error.dependencyChain);\n    console.error('Code:', error.code); // 'CIRCULAR_DEPENDENCY'\n  } else if (error instanceof FactoryError) {\n    console.error('Factory failed for:', error.portName);\n    console.error('Original error:', error.cause);\n  } else if (error instanceof ScopeRequiredError) {\n    console.error('Must resolve from scope:', error.portName);\n  } else if (error instanceof DisposedScopeError) {\n    console.error('Cannot resolve from disposed scope');\n  }\n}\n```\n\n## Documentation\n\n- [Getting Started Guide](./docs/getting-started/README.md) - Installation, core concepts, first application\n- [API Reference](./docs/api/README.md) - Complete API documentation for all packages\n- [Guides](./docs/guides/README.md) - React integration, testing strategies, DevTools usage\n- [Patterns](./docs/patterns/README.md) - Project structure, composing graphs, best practices\n- [Examples](./docs/examples/README.md) - Real-world examples and code snippets\n\n## Examples\n\nSee the [React Showcase](./examples/react-showcase) for a complete example demonstrating:\n\n- All three lifetime scopes (singleton, scoped, request)\n- React integration with typed hooks\n- Automatic scope lifecycle management\n- DevTools integration\n- Reactive updates with subscriptions\n\n## TypeScript Configuration\n\nHexDI requires TypeScript 5.0+ with strict mode enabled:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"moduleResolution\": \"bundler\",\n    \"target\": \"ES2022\"\n  }\n}\n```\n\n## Design Philosophy\n\nHexDI is built on these principles:\n\n1. **Compile-Time over Runtime** - Catch errors before your code runs\n2. **Type Inference** - Let TypeScript do the work, no explicit annotations needed\n3. **Immutability** - GraphBuilder returns new instances, enabling safe composition\n4. **Zero Overhead** - Phantom types and optional features add no runtime cost\n5. **Framework Agnostic** - Core packages work anywhere, React integration is optional\n\n## Inspiration\n\nHexDI draws inspiration from:\n\n- **Effect-TS** - Layer composition pattern and immutable builder design\n- **Hexagonal Architecture** - Ports and adapters terminology\n- **InversifyJS** - Container-based dependency injection for TypeScript\n\n## Contributing\n\nContributions are welcome! Please see our [Contributing Guide](./CONTRIBUTING.md) for details.\n\n## License\n\nMIT License - see [LICENSE](./LICENSE) for details.\n",
  "installCommand": "git clone https://github.com/leaderiop/hex-di ~/.claude/skills/hex-di",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}