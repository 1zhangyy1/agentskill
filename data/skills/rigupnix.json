{
  "id": "be2993aae3c85770",
  "slug": "rigupnix",
  "name": "Rigup.nix",
  "description": "Build your AI agent's rig: parameterizable skills and tools, all packaged together in a reproducible fashion via Nix modules",
  "author": "YPares",
  "authorAvatar": "https://avatars.githubusercontent.com/u/1377233?v=4",
  "repoUrl": "https://github.com/YPares/rigup.nix",
  "repoFullName": "YPares/rigup.nix",
  "stars": 7,
  "forks": 0,
  "category": "devops",
  "categories": [
    "devops"
  ],
  "tags": [
    "agent-rig",
    "ai-agents",
    "nix",
    "riglets",
    "skills"
  ],
  "tier": 3,
  "status": "active",
  "createdAt": "2025-12-13T02:46:32Z",
  "updatedAt": "2025-12-19T00:24:57Z",
  "lastCommitAt": "2025-12-19T00:24:53Z",
  "source": "github-search",
  "collectedAt": "2025-12-19T03:42:54.213Z",
  "authorUrl": "https://github.com/YPares",
  "license": "MIT",
  "readme": "![logo](assets/logo/rigup-logo.jpg)\n\n# Self-Contained, Modular, Reusable AI Agent Skills\n\n`rigup` is a Nix-based system for packaging AI agent skills with the tools and config needed to execute them.\n\nA _riglet_ is _executable knowledge_:\n\n- metadata to indicate to your agent what this riglet is for and when it is useful to consult it\n- a set of operations, instructions, processes, a.k.a a new [skill](https://code.claude.com/docs/en/skills) for your agent. These instructions are _lazily_ loaded: your agent reads them when it needs to, or is prompted to\n- the tools (nix packages) needed to execute these instructions\n- the configuration for these tools (if any)\n\nBy combining the relevant riglets together, you build your agent's _rig_: the tools it needs to work on your project, and the operational knowledge it needs to use those tools properly and efficiently.\n\n`rigup` has a \"knowledge-first\" design: documentation is the payload, tools are dependencies\n\nIn short, `rigup` is **Claude Skills + lightweight [home management](https://github.com/nix-community/home-manager)** for your agent.\n\n## Quick start\n\nYou can create a new project from the template provided by this repository, or even directly build\nthe example rig defined here.\n\n### Create a new project\n\n```bash\n# Initialize a new project from the template\nmkdir new-project && cd new-project && nix flake init -t github:YPares/rigup.nix\n# ...or use `-t github:YPares/rigup.nix#minimal` for a project which should not define any local riglet\n\n# Build your rig\nnix build\n\n# Explore the rig\ncat result/RIG.md\n```\n\nThis creates a basic project structure with an example riglet. Edit `riglets/my-first-riglet.nix` and `rigup.toml` to customize it.\n\n### Use the example rig from this project\n\nThis project defines example riglets, and an example rig combining them.\n\n```bash\n# Build a simple but complete agent rig:\nnix build github:YPares/rigup.nix#rigs.x86_64-linux.example-rig.home\n\n# Discover available riglets\ncat result/RIG.md\n\n# Use the tools\n./result/bin/jj --version\n\n# Read the documentation\ncat result/docs/jj-basics/SKILL.md\n```\n\n## Deeper dive\n\nThis section covers the general workflow of defining and editing riglets and rigs.\n\n### Creating a riglet\n\nRiglets are a simple use case of [Nix modules](https://nix.dev/tutorials/module-system/a-basic-module/).\n\nConcretely, this means a riglet (in its most general form) is a `(config, dependencies) -> data` Nix function, where:\n\n- `config` is the final config of the rig which the riglet is part of,\n- `data` is a dictionary-like structure (\"attribute set\" in Nix lingo) providing nested fields that will _themselves_ contribute to the final aggregated config\n\nCreate a `riglets/` folder at the root of your project.\nThen add to it a `<riglet-name>.nix` file:\n\n```nix\n# riglets/my-riglet.nix\n\n# First argument: the defining flake's `self` - gives access to:\n#   - `self.inputs.*` for external package dependencies\n#   - `self.riglets.*` for inter-riglet imports\n# Just use `_` if you don't need it\n_:\n\n# Second argument: module args constructed by the _user_ of the riglet, when the full rig is built\n# - config is the final aggregated config of the rig using my-riglet,\n# - pkgs is your usual imported nixpkgs,\n# - system is just pkgs.stdenv.hostPlatform.system, for quicker access\n# - riglib is injected by rigup, and contains utility functions to build riglets\n{ config, pkgs, system, riglib, ... }: {\n\n  # Each riglet must declare itself under config.riglets.<riglet-name>\n  config.riglets.my-riglet = {\n\n    # (Optional) The tools needed by this riglet\n    tools = [ pkgs.mytool ./path/to/some/script.sh ];\n\n    # The metadata that will enable your agent to know what this riglet\n    # provides and when it should be consulted\n    meta = {\n      name = \"My Riglet\";\n      intent = \"cookbook\";\n        # 'sourcebook', 'toolbox', 'cookbook', or 'playbook':\n        # what should the agent expect from this riglet: general knowledge\n        # that may come useful vs. highly specific procedure(s) to follow\n      description = \"What this provides\";\n      whenToUse = [ \"When you need X\" ];\n      keywords = [ \"search\" \"terms\" ];\n      status = \"draft\";\n      version = \"0.1.0\";\n    };\n\n    # The Skill part of the riglet. It is a file hierarchy that should contain a\n    # SKILL.md entry right under the root\n    docs = riglib.writeFileTree {\n      # Use inline strings...\n      \"SKILL.md\" = ''\n        # My Riglet Documentation\n\n        ...\n\n        For more advanced cases, see references/advanced-cases.md\n      '';\n      references = {\n        # ...or local file paths...\n        \"advanced-cases.md\" = ./path/to/advanced-cases.md;\n        # ...or derivations that build a file\n        \"foo.md\" = pkgs.writeText \"foo.md\" (mkFooContents x y z t);\n      };\n    };\n\n    # Alternatively, if you already have a folder that follows the Agent Skill convention,\n    # (SKILL.md at the top and references/*.md files), you can directly reuse it:\n    #docs = ./path/to/skill/folder;\n\n    # (Optional) The configuration that the tools should use\n    # These will go under `.config` in the final \"home directory\" of the rig\n    config-files = riglib.writeFileTree {\n      # .config/mytool/config.toml\n      mytool.\"config.toml\" = ''\n        setting = \"value\"\n      '';\n    };\n\n  };\n\n}\n```\n\n...or just ask your agent to do it! :) `rigup.nix` comes with the `riglet-creator` riglet that teaches your agent to write riglets and... and, ahem, yes that's becoming very meta, sorry about that.\n\nJust as with regular Agent Skills, the point of separating the docs into several files\nis to allow [_progressive disclosure_](https://en.wikipedia.org/wiki/Progressive_disclosure).\nWhen using AI Agents, this is important because [context](https://www.ibm.com/think/topics/context-window) is on a budget, and agents should not have to read [more documentation than they need](https://medium.com/@cdcore/mcp-is-broken-and-anthropic-just-admitted-it-7eeb8ee41933) to complete a task.\n\n#### Alternative structure\n\nInstead of `riglets/<riglet-name>.nix`, you can define your riglet as `riglets/<riglet-name>/default.nix` to add supporting files next to it:\n\n```\nriglets/\n├── simple-riglet.nix          # Single-file riglet\n└── complex-riglet/            # Directory-based riglet\n    ├── default.nix            # Main riglet definition\n    ├── SKILL.md               # Referenced in default.nix via ./SKILL.md\n    └── references/\n        └── advanced.md        # Referenced in default.nix via ./references/advanced.md\n```\n\nThis is useful to break up a riglet into various Nix or raw text files to make it more manageable.\n`rigup` will discover and treat both layouts identically.\n\n#### Inter-riglet dependencies\n\nIf a riglet depends on another (e.g., builds on its concepts or requires its tools), use `imports` with `self.riglets.*`:\n\n```nix\n# riglets/advanced-riglet.nix\nself:\n{ riglib, ... }: {\n  # Import the base riglet - if both are added to a rig, evalModules deduplicates\n  imports = [ self.riglets.base-riglet ];\n\n  config.riglets.advanced-riglet = {\n    # ...\n  };\n}\n```\n\n**Important:** Always use `self.riglets.*` for imports, never path-based imports like `./base-riglet.nix`. The `self.riglets.*` form ensures proper deduplication when the same riglet is included both directly and via imports.\n\nFor dependencies on riglets from external flakes:\n\n```nix\nself:\n{ riglib, ... }: {\n  imports = [ self.inputs.other-flake.riglets.some-riglet ];\n  # ...\n}\n```\n\n#### Using external packages\n\nRiglets can access packages from external flakes via `self.inputs`:\n\n```nix\nself:\n{ pkgs, system, riglib, ... }: {\n  config.riglets.my-riglet = {\n    tools =\n      let someFlakePkgs = self.inputs.some-flake.packages.${system};\n      in [\n        someFlakePkgs.default\n        pkgs.git\n      ];\n  };\n}\n```\n\nThis lets riglets bundle their own dependencies without requiring consumers to know about them.\n\n### Creating a rig\n\n#### Simple option: `rigup.toml`\n\nDefine rigs in `rigup.toml` at the top of your project:\n\n```toml\n# Riglets to include in this rig, grouped by source\n[rigs.default.riglets]\nrigup = [\"jj-basics\", \"typst-reporter\"]  # From the rigup flake input\nself = [\"my-local-riglet\"]               # From your riglets/ folder\n\n# Configuration for the riglets used in this rig\n[rigs.default.config.agent.user]\nname = \"Alice\"  # This is used by both jj-basics & typst-reporter example riglets\nemail = \"alice@example.com\"\n```\n\nYour `flake.nix` should be:\n\n```nix\n{\n  inputs.rigup.url = \"github:YPares/rigup.nix\";\n\n  outputs = { self, rigup, ... }@inputs:\n    let\n      system = \"x86_64-linux\";\n      rig = self.rigs.${system}.default;\n    in rigup { inherit inputs; } // {\n      # Expose the whole rig directly as an output package, so it is easy to build as a folder\n      packages.${system}.default-rig = rig.home;\n      # Expose the whole rig directly as an output devShell, so you can enter it directly\n      devShells.${system}.default-rig = rig.shell;\n    };\n}\n```\n\nFinally, build the rig with:\n\n```shell\nnix build .#default-rig -o my-default-rig\nls -la ./my-default-rig\n```\n\n...or enter it through a sub-shell with:\n\n```shell\nnix develop .#default-rig\n```\n\nThe riglets listed in your `rigup.toml` **must** match your flake inputs and what exists in your project. As a general case:\n\n```toml\n[rigs.my-rig.riglets]\nsome-flake = [\"foo\", \"bar\"]\n```\n\nmeans that your `flake.nix` has a `some-flake` input that exposes the `riglets.foo` and `riglets.bar` outputs.\n`self` is just a special case of that, as every flake has an implicit `self` input which is the flake itself.\n\n**NOTE:** The main reason to use a TOML file instead of always defining everything as Nix code is not _just_ because TOML is (much) more well-known than Nix syntax.\nIt is mainly because pure data (that can already cover a large set of use cases) is easier to manipulate via CLI tools than Nix code (see [TODO section](#todo) below).\n\n#### Advanced option: combine with Nix\n\n...that being said, building rigs directly in Nix (if you need the full Nix power to write your rig's configuration) is totally supported:\n\n```nix\n{\n  inputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n  inputs.rigup.url = \"github:YPares/rigup.nix\";\n  inputs.foo.url = \"github:bar/foo\";\n\n  outputs = { self, rigup, nixpkgs, foo, ... }@inputs:\n    let\n      system = \"x86_64-linux\";\n      pkgs = import nixpkgs { inherit system; };\n    in\n    rigup { inherit inputs; } // {\n      # Override or extend with custom rigs\n      rigs.${system}.custom = rigup.lib.buildRig {\n        inherit pkgs;\n        modules = [\n          self.riglets.aaa # Will use `$PROJECT_ROOT/riglets/{aaa.nix,aaa/default.nix}`\n          foo.riglets.bbb  # Use external riglets defined by our inputs\n          foo.riglets.ccc\n          # Extra config is given in the form of a simple in-line Nix module,\n          # with or without `{ config, pkgs, riglib, ... }` arguments\n          {\n            config = {\n              # More advanced config, that e.g. requires direct access to some Nix functions,\n              # or even takes the form of Nix functions:\n              aaa-config.i-need-a-derivation = pkgs.someDerivationBuilder \"...\" \"........\";\n              bbbModuleOpts.conditions.is-x-y-pair-valid = x: y: x * y <= 42.420000000000001;\n            }\n          }\n        ];\n      };\n\n      # (Same as before) Optionally expose more directly whole rigs as output packages\n      packages.${system}.custom-rig = self.rigs.${system}.custom.home;\n    };\n}\n```\n\n**IMPORTANT:** This makes the `rigup.toml` entirely _optional_, but it is **still necessary** to use `rigup { inherit inputs; }` to construct your flake's outputs.\nThis is so `rigup` can discover which riglets are defined in your `$PROJECT_ROOT/riglets/` and set up the `riglets` output of your flake.\n\nAs the above suggests, you can totally mix both options: define some simple rigs in the `rigup.toml` and some advanced ones in Nix code.\nAlthough, prefer splitting you rigs' definitions in separate Nix files rather than declaring everything in your `flake.nix`, the example above is just for the sake of concision.\n\n## Features\n\n- **Data-driven config:** `rigup.toml` for CLI-manageable rigs\n- **Auto-discovery:** Riglets from `riglets/` automatically exposed\n- **Type-checked metadata:** Nix validates riglet structure\n- **Lazily readable documentation:** Skills-style SKILL.md + references/\n- **Declarative composition:** Module system for riglet interaction\n- **Auto-generated manifests:** RIG.md lists all capabilities\n- **Reproducible:** Nix ensures consistent tool versions\n- **Self-documenting:** Riglets like `agent-rig`, `riglet-creator`, and `nix-module-system` teach agents how the system works — so they can help you write Nix and extend your rig. Learn Nix as a side effect, with AI assistance.\n\n## Layout of this repository\n\n```\nrigup.nix/\n├── lib/\n│   ├── default.nix       # riglib (common functions to define riglets)\n│   ├── manifest.nix      # RIG.md generation\n│   └── rigletSchema.nix  # Riglet type definitions\n├── riglets/\n│   ├── agent-rig         # Meta-documentation about the rig system\n│   ├── riglet-creator    # Guide to writing riglets\n│   ├── nix-module-system # Dark corners of Nix modules (evalModules, mkDefault, etc.)\n│   └── ...               # Other example riglets\n├── rigup.toml            # Declares the example rig\n└── flake.nix             # Exposes the Nix library + the above riglets & rig as outputs\n```\n\n## TODO\n\n- Add `checks` to riglets: automated and/or through-agent testing that a riglet is working as intended\n- `rigup` CLI tool for convenient rig access and manipulation of the `rigup.toml` file, via an interface like:\n  - `rigup add --rig <rig> --input <flake-url> <riglet>`\n  - `rigup config list --rig <rig>`\n  - `rigup config set --rig <rig> foo.bar.qux <value>`\n  - `rigup start --rig <rig> claude`\n  - etc.\n- [`minijinja`](https://github.com/mitsuhiko/minijinja)-based templating for easy modular docs that adapt based on the rig's config\n- More example riglets\n\n## Related projects\n\n- [`openskills`](https://github.com/numman-ali/openskills): Universal Skill loader, following Claude Skills system and manifest\n- [`llm-agents.nix`](https://github.com/numtide/llm-agents.nix): Numtide's flake packaging AI coding agents and development tools\n\n## License\n\nMIT\n\n______________________________________________________________________\n\n*Built with Nix • Formatting: nixfmt-rfc-style • Uses [blueprint](https://github.com/numtide/blueprint)*\n",
  "installCommand": "git clone https://github.com/YPares/rigup.nix ~/.claude/skills/rigupnix",
  "defaultBranch": "main",
  "hasMarketplaceJson": false,
  "skillPath": "README.md"
}